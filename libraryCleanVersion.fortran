! LIBRARY OF FUNCTIONS

      module functions
        ! constants
        ! do i = 0, ITERATIONS
        !   i*STEP
        ! goes from 0 to 2.5, only change 2.5 for desired interval
        integer, parameter :: ITERATIONS = 2500
        real, parameter :: STEP = 2.5/real(ITERATIONS)

        contains

! MODIFY Dv
! Dv is the system of equations
! v = [y, Dy]
! Dv = [Dy, DDy], example equation:
! DDy - 2*x*Dy + 2*y = 0
! then Dv(1) and Dv(2):
        function Dv(x,v) 
          real, intent(in) :: x, v(2)
          real :: Dv(2)
          Dv(1) = v(2)
          Dv(2) = 2*x*v(2)-2*v(1)
        end function Dv

        function factorial(x)
          real, intent(in) :: x
          real :: factorial
          factorial = gamma(x+1)
        end function factorial

! hermite polynomial
        function hermitePoly(n,x)
          real, intent(in) :: n, x
          real :: hermitePoly
          integer :: s

          hermitePoly = 0
          do s=0,floor(n/2)
            hermitePoly =
     &      hermitePoly+
     &      ((((-1)**s)*factorial(n+1))/
     &      (factorial(real(n-2*s)+1)*factorial(real(s)+1)))
     &      *((2*x)**(real(n-2*s)))
          end do 

        end function hermitePoly

      end module functions

      module rungeKutta
        use functions
        contains

! function Dv has to match function in module functions
! usage example
! v_i+1 = RK4(x_i,v_i,stepSize)
! v_i is the old [v, Dv] vector

        function RK4(x,v,stepSize)
          real, intent(in) :: x, v(2), stepSize
          real :: k(4,2), RK4(2)

          k(1,:) = Dv(x,v)
          k(2,:) = Dv(x+stepSize/2,v+k(1,:)*stepSize/2)
          k(3,:) = Dv(x+stepSize/2,v+k(2,:)*stepSize/2)
          k(4,:) = Dv(x+stepSize,v+k(3,:)*stepSize)

          RK4 = v+stepSize*(k(1,:)+2*k(2,:)+2*k(3,:)+k(4,:))/6

        end function RK4
      end module rungeKutta

      module moduleIterativeRK4
        use rungeKutta
        implicit none

        contains
        
        function iterativeRK4(vector,x_old,x) result(v)
          real, intent(in) :: x, x_old, vector(2)
          real :: t, newstep
          real :: v(2)

          v = vector
          t = x_old

          if (abs(x-t) > 0.001) then
            ! keep direction but change size of step to 0.001 for
            ! precision
            newstep = (x-t)/abs(x-t)*0.001
            do
              if (abs(t+newstep) >= abs(x)) then
                newstep = x-t
                exit
              end if
              v = RK4(t,v,newstep)
              t = t+newstep
            end do
          else
            newstep = x-t
          end if

          v = RK4(t,v,newstep)
          t = t + newstep
        end function iterativeRK4

      end module moduleIterativeRK4
